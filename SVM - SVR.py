# -*- coding: utf-8 -*-
"""OCDS - Lab 08.3 - SVM - SVR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K7fpYqKS2F3NP8RcTn3K5jEZ8-iHxVyv

# SVM - SVR
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn.svm import SVR
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_validate, GridSearchCV
import warnings
warnings.filterwarnings("ignore")

# data = pd.read_csv('D:/APU/CT108-3-3 - OCDS/Lab Sessions/Lab8 - SVM/kc_house_data.csv')
from google.colab import files
file = files.upload()
import io
data = pd.read_csv(io.BytesIO(file['kc_house_data.csv']))
data.head()

data = data.drop(['id', 'date', 'yr_renovated', 'zipcode', 'lat', 'long'], axis=1)
data.head()

data.shape

data.describe()

data.isnull().sum()

data.hist(figsize=(15,15), edgecolor="blue", color="blue")
plt.show()

X = data.iloc[:, 1:14].values
y = data.iloc[:, 0].values

sc_X = StandardScaler()
X = sc_X.fit_transform(X)

y

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state=0)

"""**Using Linear Kernel**"""

import math
grid_search_svr_lnr = GridSearchCV(estimator=SVR(kernel='linear'),
                       param_grid={'C': [0.1, 1, 10, 100],
                                   'epsilon': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10],},
                       cv=5, scoring='neg_mean_squared_error', verbose=0, n_jobs=-1)

grid_result = grid_search_svr_lnr.fit(X_train, y_train)
best_params = grid_result.best_params_
print(best_params)

best_svr = SVR(kernel='linear', C=best_params["C"], epsilon=best_params["epsilon"], coef0=0.1, shrinking=True,
                   tol=0.001, cache_size=200, verbose=False, max_iter=-1)

scoring = {'abs_error': 'neg_mean_absolute_error', 'squared_error': 'neg_mean_squared_error'}

scores = cross_validate(best_svr, X_train, y_train, cv=5, scoring=scoring, return_train_score=True)

LMAE=abs(scores['test_abs_error'].mean())
LRMSE=math.sqrt(abs(scores['test_squared_error'].mean()))

print('\nMAE of Linear Kernel = ', LMAE)
print('RMSE of Linear kernel = ', LRMSE)

best_svr.fit(X_train, y_train)
y_pred_lnr = best_svr.predict(X_test)
y_pred_lnr

df2 = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred_lnr.round(2)})
df2.head()

"""**Using Polynomial Kernel**"""

import math
grid_search_svr_poly = GridSearchCV(estimator=SVR(kernel='poly'),
                      param_grid={
                                  'C': [0.1, 1, 100, 1000],
                                  'epsilon': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10],
                                  'degree': [2, 3, 4],
                                  'coef0': [0.1, 0.01, 0.001, 0.0001]},
                                  cv=5, scoring='neg_mean_squared_error', verbose=0, n_jobs=-1)

grid_result = grid_search_svr_poly.fit(X_train, y_train)
best_params = grid_result.best_params_
print(best_params)

best_svr = SVR(kernel='poly', C=best_params["C"], epsilon=best_params["epsilon"], coef0=best_params["coef0"],
               degree=best_params["degree"], shrinking=True,
               tol=0.001, cache_size=200, verbose=False, max_iter=-1)

scoring = {'abs_error': 'neg_mean_absolute_error', 'squared_error': 'neg_mean_squared_error'}

scores = cross_validate(best_svr, X_train, y_train, cv=5, scoring=scoring, return_train_score=True)

PMAE=abs(scores['test_abs_error'].mean())
PRMSE=math.sqrt(abs(scores['test_squared_error'].mean()))

print('\nMAE of Polynomial Kernel = ', PMAE)
print('RMSE of Polynomial kernel = ', PRMSE)

best_svr.fit(X_train, y_train)
y_pred_poly = best_svr.predict(X_test)
y_pred_poly

df3 = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred_poly.round(2)})
df3.head()

"""**Using RBF Kernel**"""

import math
grid_search_svr_rbf = GridSearchCV(estimator=SVR(kernel='rbf'),
                                    param_grid={
                                                'C': [0.1, 1, 100, 1000],
                                                'epsilon': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10],
                                                'gamma': [0.0001, 0.001, 0.005, 0.1, 1, 3, 5]
                                                },
                                                cv=5, scoring='neg_mean_squared_error', verbose=0, n_jobs=-1)

grid_result = grid_search_svr_rbf.fit(X_train, y_train)
best_params = grid_result.best_params_
print(best_params)

best_svr = SVR(kernel='rbf', C=best_params["C"], epsilon=best_params["epsilon"], gamma=best_params["gamma"],
                   coef0=0.1, shrinking=True,
                   tol=0.001, cache_size=200, verbose=False, max_iter=-1)

scoring = {'abs_error': 'neg_mean_absolute_error', 'squared_error': 'neg_mean_squared_error'}

scores = cross_validate(best_svr, X_train, y_train, cv=5, scoring=scoring, return_train_score=True)

RMAE=abs(scores['test_abs_error'].mean())
RRMSE=math.sqrt(abs(scores['test_squared_error'].mean()))

print('\nMAE of RBF Kernel = ', RMAE)
print('RMSE of RBF kernel = ', RRMSE)

best_svr.fit(X_train, y_train)
y_pred_rbf = best_svr.predict(X_test)
y_pred_rbf

df4 = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred_rbf.round(2)})
df4.head()